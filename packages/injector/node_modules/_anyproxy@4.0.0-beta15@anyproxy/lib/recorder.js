'use strict';

//start recording and share a list when required

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Datastore = require('nedb'),
    path = require('path'),
    fs = require('fs'),
    events = require('events'),
    iconv = require('iconv-lite'),
    proxyUtil = require('./util');

var BODY_FILE_PRFIX = 'res_body_';
var CACHE_DIR_PREFIX = 'cache_r';
function getCacheDir() {
  var rand = Math.floor(Math.random() * 1000000),
      cachePath = path.join(proxyUtil.getAnyProxyPath('cache'), './' + CACHE_DIR_PREFIX + rand);

  fs.mkdirSync(cachePath);
  return cachePath;
}

function normalizeInfo(id, info) {
  var singleRecord = {};

  //general
  singleRecord._id = id;
  singleRecord.id = id;
  singleRecord.url = info.url;
  singleRecord.host = info.host;
  singleRecord.path = info.path;
  singleRecord.method = info.method;

  //req
  singleRecord.reqHeader = info.req.headers;
  singleRecord.startTime = info.startTime;
  singleRecord.reqBody = info.reqBody || '';
  singleRecord.protocol = info.protocol || '';

  //res
  if (info.endTime) {
    singleRecord.statusCode = info.statusCode;
    singleRecord.endTime = info.endTime;
    singleRecord.resHeader = info.resHeader;
    singleRecord.length = info.length;
    var contentType = info.resHeader['content-type'] || info.resHeader['Content-Type'];
    if (contentType) {
      singleRecord.mime = contentType.split(';')[0];
    } else {
      singleRecord.mime = '';
    }

    singleRecord.duration = info.endTime - info.startTime;
  } else {
    singleRecord.statusCode = '';
    singleRecord.endTime = '';
    singleRecord.resHeader = '';
    singleRecord.length = '';
    singleRecord.mime = '';
    singleRecord.duration = '';
  }

  return singleRecord;
}

var Recorder = function (_events$EventEmitter) {
  (0, _inherits3.default)(Recorder, _events$EventEmitter);

  function Recorder(config) {
    (0, _classCallCheck3.default)(this, Recorder);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Recorder.__proto__ || Object.getPrototypeOf(Recorder)).call(this, config));

    _this.globalId = 1;
    _this.cachePath = getCacheDir();
    _this.db = new Datastore();
    _this.db.persistence.setAutocompactionInterval(5001);

    _this.recordBodyMap = []; // id - body
    return _this;
  }

  (0, _createClass3.default)(Recorder, [{
    key: 'emitUpdate',
    value: function emitUpdate(id, info) {
      var self = this;
      if (info) {
        self.emit('update', info);
      } else {
        self.getSingleRecord(id, function (err, doc) {
          if (!err && !!doc && !!doc[0]) {
            self.emit('update', doc[0]);
          }
        });
      }
    }
  }, {
    key: 'updateRecord',
    value: function updateRecord(id, info) {
      if (id < 0) return;
      var self = this;
      var db = self.db;

      var finalInfo = normalizeInfo(id, info);

      db.update({ _id: id }, finalInfo);
      self.updateRecordBody(id, info);

      self.emitUpdate(id, finalInfo);
    }
  }, {
    key: 'updateExtInfo',
    value: function updateExtInfo(id, extInfo) {
      var self = this;
      var db = self.db;

      db.update({ _id: id }, { $set: { ext: extInfo } }, {}, function (err, nums) {
        if (!err) {
          self.emitUpdate(id);
        }
      });
    }
  }, {
    key: 'appendRecord',
    value: function appendRecord(info) {
      if (info.req.headers.anyproxy_web_req) {
        //TODO request from web interface
        return -1;
      }
      var self = this;
      var db = self.db;

      var thisId = self.globalId++;
      var finalInfo = normalizeInfo(thisId, info);
      db.insert(finalInfo);
      self.updateRecordBody(thisId, info);

      self.emitUpdate(thisId, finalInfo);
      return thisId;
    }
  }, {
    key: 'updateRecordBody',
    value: function updateRecordBody(id, info) {
      var self = this;
      var cachePath = self.cachePath;

      if (id === -1) return;

      if (!id || !info.resBody) return;
      //add to body map
      //ignore image data
      var bodyFile = path.join(cachePath, BODY_FILE_PRFIX + id);
      fs.writeFile(bodyFile, info.resBody, function () {});
    }
  }, {
    key: 'getBody',
    value: function getBody(id, cb) {
      var self = this;
      var cachePath = self.cachePath;

      if (id < 0) {
        cb && cb('');
      }

      var bodyFile = path.join(cachePath, BODY_FILE_PRFIX + id);
      fs.access(bodyFile, fs.F_OK | fs.R_OK, function (err) {
        if (err) {
          cb && cb(err);
        } else {
          fs.readFile(bodyFile, cb);
        }
      });
    }
  }, {
    key: 'getDecodedBody',
    value: function getDecodedBody(id, cb) {
      var self = this;
      var result = {
        type: 'unknown',
        mime: '',
        content: ''
      };
      self.getSingleRecord(id, function (err, doc) {
        //check whether this record exists
        if (!doc || !doc[0]) {
          cb(new Error('failed to find record for this id'));
          return;
        }

        self.getBody(id, function (error, bodyContent) {
          if (error) {
            cb(error);
          } else if (!bodyContent) {
            cb(null, result);
          } else {
            var record = doc[0],
                resHeader = record.resHeader || {};
            try {
              var headerStr = JSON.stringify(resHeader),
                  charsetMatch = headerStr.match(/charset='?([a-zA-Z0-9-]+)'?/),
                  contentType = resHeader && (resHeader['content-type'] || resHeader['Content-Type']);

              if (charsetMatch && charsetMatch.length) {
                var currentCharset = charsetMatch[1].toLowerCase();
                if (currentCharset !== 'utf-8' && iconv.encodingExists(currentCharset)) {
                  bodyContent = iconv.decode(bodyContent, currentCharset);
                }

                result.mime = contentType;
                result.content = bodyContent.toString();
                result.type = contentType && /application\/json/i.test(contentType) ? 'json' : 'text';
              } else if (contentType && /image/i.test(contentType)) {
                result.type = 'image';
                result.mime = contentType;
                result.content = bodyContent;
              } else {
                result.type = contentType;
                result.mime = contentType;
                result.content = bodyContent.toString();
              }
              result.fileName = path.basename(record.path);
              result.statusCode = record.statusCode;
            } catch (e) {
              console.error(e);
            }
            cb(null, result);
          }
        });
      });
    }
  }, {
    key: 'getSingleRecord',
    value: function getSingleRecord(id, cb) {
      var self = this;
      var db = self.db;
      db.find({ _id: parseInt(id, 10) }, cb);
    }
  }, {
    key: 'getSummaryList',
    value: function getSummaryList(cb) {
      var self = this;
      var db = self.db;
      db.find({}, cb);
    }
  }, {
    key: 'getRecords',
    value: function getRecords(idStart, limit, cb) {
      var self = this;
      var db = self.db;
      limit = limit || 10;
      idStart = typeof idStart === 'number' ? idStart : self.globalId - limit;
      db.find({ _id: { $gte: parseInt(idStart, 10) } }).sort({ _id: 1 }).limit(limit).exec(cb);
    }
  }, {
    key: 'clear',
    value: function clear() {
      var self = this;
      proxyUtil.deleteFolderContentsRecursive(self.cachePath, true);
    }
  }]);
  return Recorder;
}(events.EventEmitter);

module.exports = Recorder;