'use strict';

//manage https servers

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var async = require('async'),
    https = require('https'),
    tls = require('tls'),
    crypto = require('crypto'),
    color = require('colorful'),
    certMgr = require('./certMgr'),
    logUtil = require('./log'),
    util = require('./util'),
    co = require('co'),
    constants = require('constants'),
    asyncTask = require('async-task-mgr');

var createSecureContext = tls.createSecureContext || crypto.createSecureContext;

//using sni to avoid multiple ports
function SNIPrepareCert(serverName, SNICallback) {
  var keyContent = void 0,
      crtContent = void 0,
      ctx = void 0;

  async.series([function (callback) {
    certMgr.getCertificate(serverName, function (err, key, crt) {
      if (err) {
        callback(err);
      } else {
        keyContent = key;
        crtContent = crt;
        callback();
      }
    });
  }, function (callback) {
    try {
      ctx = createSecureContext({
        key: keyContent,
        cert: crtContent
      });
      callback();
    } catch (e) {
      callback(e);
    }
  }], function (err) {
    if (!err) {
      var tipText = 'proxy server for __NAME established'.replace('__NAME', serverName);
      logUtil.printLog(color.yellow(color.bold('[internal https]')) + color.yellow(tipText));
      SNICallback(null, ctx);
    } else {
      logUtil.printLog('err occurred when prepare certs for SNI - ' + err, logUtil.T_ERR);
      logUtil.printLog('err occurred when prepare certs for SNI - ' + err.stack, logUtil.T_ERR);
    }
  });
}

//config.port - port to start https server
//config.handler - request handler


/**
 * Create an https server
 * 
 * @param {object} config
 * @param {number} config.port
 * @param {function} config.handler
 */
function createHttpsServer(config) {
  if (!config || !config.port || !config.handler) {
    throw new Error('please assign a port');
  }

  return new Promise(function (resolve) {
    certMgr.getCertificate('anyproxy_internal_https_server', function (err, keyContent, crtContent) {
      var server = https.createServer({
        secureOptions: constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1,
        SNICallback: SNIPrepareCert,
        key: keyContent,
        cert: crtContent
      }, config.handler).listen(config.port);

      resolve(server);
    });
  });
}

/**
 * 
 * 
 * @class httpsServerMgr
 * @param {object} config
 * @param {function} config.handler handler to deal https request
 * 
 */

var httpsServerMgr = function () {
  function httpsServerMgr(config) {
    (0, _classCallCheck3.default)(this, httpsServerMgr);

    if (!config || !config.handler) {
      throw new Error('handler is required');
    }
    this.instanceHost = '127.0.0.1';
    this.httpsAsyncTask = new asyncTask();
    this.handler = config.handler;
  }

  (0, _createClass3.default)(httpsServerMgr, [{
    key: 'getSharedHttpsServer',
    value: function getSharedHttpsServer() {
      var self = this;
      function prepareServer(callback) {
        var instancePort = void 0;
        co(util.getFreePort).then(co.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee(port) {
          var httpsServer, result;
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  instancePort = port;
                  _context.next = 3;
                  return createHttpsServer({
                    port: port,
                    handler: self.handler
                  });

                case 3:
                  httpsServer = _context.sent;


                  httpsServer.on('upgrade', function (req, socket, head) {
                    var reqHost = req.headers.host || 'unknown host';
                    logUtil.printLog('wss:// is not supported when intercepting https. This request will be closed by AnyProxy. You may either exclude this domain in your rule file, or stop all https intercepting. (' + reqHost + ')', logUtil.T_ERR);
                    socket.end();
                  });
                  result = {
                    host: self.instanceHost,
                    port: instancePort
                  };

                  callback(null, result);
                  return _context.abrupt('return', result);

                case 8:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }))).catch(function (e) {
          callback(e);
        });
      }

      return new Promise(function (resolve, reject) {
        self.httpsAsyncTask.addTask('createHttpsServer', prepareServer, function (error, serverInfo) {
          if (error) {
            reject(error);
          } else {
            resolve(serverInfo);
          }
        });
      });
    }
  }]);
  return httpsServerMgr;
}();

module.exports = httpsServerMgr;