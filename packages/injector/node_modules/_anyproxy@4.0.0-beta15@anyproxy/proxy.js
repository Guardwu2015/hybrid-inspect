'use strict';

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var http = require('http'),
    https = require('https'),
    async = require('async'),
    color = require('colorful'),
    certMgr = require('./lib/certMgr'),
    Recorder = require('./lib/recorder'),
    logUtil = require('./lib/log'),
    util = require('./lib/util'),
    events = require('events'),
    co = require('co'),
    WebInterface = require('./lib/webInterface'),
    ThrottleGroup = require('stream-throttle').ThrottleGroup;

// const memwatch = require('memwatch-next');

// setInterval(() => {
//   console.log(process.memoryUsage());
//   const rss = Math.ceil(process.memoryUsage().rss / 1000 / 1000);
//   console.log('Program is using ' + rss + ' mb of Heap.');
// }, 1000);

// memwatch.on('stats', (info) => {
//   console.log('gc !!');
//   console.log(process.memoryUsage());
//   const rss = Math.ceil(process.memoryUsage().rss / 1000 / 1000);
//   console.log('GC !! Program is using ' + rss + ' mb of Heap.');

//   // var heapUsed = Math.ceil(process.memoryUsage().heapUsed / 1000);
//   // console.log("Program is using " + heapUsed + " kb of Heap.");
//   // console.log(info);
// });

var T_TYPE_HTTP = 'http',
    T_TYPE_HTTPS = 'https',
    DEFAULT_TYPE = T_TYPE_HTTP;

var PROXY_STATUS_INIT = 'INIT';
var PROXY_STATUS_READY = 'READY';
var PROXY_STATUS_CLOSED = 'CLOSED';

/**
 *
 * @class ProxyCore
 * @extends {events.EventEmitter}
 */

var ProxyCore = function (_events$EventEmitter) {
  (0, _inherits3.default)(ProxyCore, _events$EventEmitter);

  /**
   * Creates an instance of ProxyCore.
   *
   * @param {object} config - configs
   * @param {number} config.port - port of the proxy server
   * @param {object} [config.rule=null] - rule module to use
   * @param {string} [config.type=http] - type of the proxy server, could be 'http' or 'https'
   * @param {strign} [config.hostname=localhost] - host name of the proxy server, required when this is an https proxy
   * @param {number} [config.throttle] - speed limit in kb/s
   * @param {boolean} [config.forceProxyHttps=false] - if proxy all https requests
   * @param {boolean} [config.silent=false] - if keep the console silent
   * @param {boolean} [config.dangerouslyIgnoreUnauthorized=false] - if ignore unauthorized server response
   * @param {object} [config.recorder] - recorder to use
   *
   * @memberOf ProxyCore
   */
  function ProxyCore(config) {
    (0, _classCallCheck3.default)(this, ProxyCore);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ProxyCore.__proto__ || Object.getPrototypeOf(ProxyCore)).call(this));

    config = config || {};

    _this.status = PROXY_STATUS_INIT;
    _this.proxyPort = config.port;
    _this.proxyType = /https/i.test(config.type || DEFAULT_TYPE) ? T_TYPE_HTTPS : T_TYPE_HTTP;
    _this.proxyHostName = config.hostname || 'localhost';
    _this.recorder = config.recorder;

    if (parseInt(process.versions.node.split('.')[0], 10) < 4) {
      throw new Error('node.js >= v4.x is required for anyproxy');
    } else if (config.forceProxyHttps && !certMgr.ifRootCAFileExists()) {
      throw new Error('root CA not found. can not intercept https'); // TODO : give a reference to user
    } else if (_this.proxyType === T_TYPE_HTTPS && !config.hostname) {
      throw new Error('hostname is required in https proxy');
    } else if (!_this.proxyPort) {
      throw new Error('proxy port is required');
    } else if (!_this.recorder) {
      throw new Error('recorder is required');
    }

    _this.httpProxyServer = null;
    _this.requestHandler = null;

    // copy the rule to keep the original proxyRule independent
    _this.proxyRule = config.rule || [];

    if (config.silent) {
      logUtil.setPrintStatus(false);
    }

    if (config.throttle) {
      logUtil.printLog('throttle :' + config.throttle + 'kb/s');
      var rate = parseInt(config.throttle, 10);
      if (rate < 1) {
        throw new Error('Invalid throttle rate value, should be positive integer');
      }
      global._throttle = new ThrottleGroup({ rate: 1024 * rate }); // rate - byte/sec
    }

    // init recorder
    _this.recorder = config.recorder;

    // init request handler
    var RequestHandler = util.freshRequire('./requestHandler');
    _this.requestHandler = new RequestHandler({
      forceProxyHttps: !!config.forceProxyHttps,
      dangerouslyIgnoreUnauthorized: !!config.dangerouslyIgnoreUnauthorized
    }, _this.proxyRule, _this.recorder);
    return _this;
  }

  /**
  * manage all created socket
  * for each new socket, we put them to a map;
  * if the socket is closed itself, we remove it from the map
  * when the `close` method is called, we'll close the sockes before the server closed
  *
  * @param {Socket} the http socket that is creating
  * @returns undefined
  * @memberOf ProxyCore
  */


  (0, _createClass3.default)(ProxyCore, [{
    key: 'handleExistConnections',
    value: function handleExistConnections(socket) {
      var self = this;
      self.socketIndex++;
      var key = 'socketIndex_' + self.socketIndex;
      self.socketPool[key] = socket;

      // if the socket is closed already, removed it from pool
      socket.on('close', function () {
        delete self.socketPool[key];
      });
    }
    /**
     * start the proxy server
     *
     * @returns ProxyCore
     *
     * @memberOf ProxyCore
     */

  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      var self = this;
      self.socketIndex = 0;
      self.socketPool = {};

      if (self.status !== PROXY_STATUS_INIT) {
        throw new Error('server status is not PROXY_STATUS_INIT, can not run start()');
      }
      async.series([
      //creat proxy server
      function (callback) {
        if (self.proxyType === T_TYPE_HTTPS) {
          certMgr.getCertificate(self.proxyHostName, function (err, keyContent, crtContent) {
            if (err) {
              callback(err);
            } else {
              self.httpProxyServer = https.createServer({
                key: keyContent,
                cert: crtContent
              }, self.requestHandler.userRequestHandler);
              callback(null);
            }
          });
        } else {
          self.httpProxyServer = http.createServer(self.requestHandler.userRequestHandler);
          callback(null);
        }
      },

      //handle CONNECT request for https over http
      function (callback) {
        self.httpProxyServer.on('connect', self.requestHandler.connectReqHandler);

        callback(null);
      }, function (callback) {
        // remember all sockets, so we can destory them when call the method 'close';
        self.httpProxyServer.on('connection', function (socket) {
          self.handleExistConnections.call(self, socket);
        });
        callback(null);
      },

      //start proxy server
      function (callback) {
        self.httpProxyServer.listen(self.proxyPort);
        callback(null);
      }],

      //final callback
      function (err, result) {
        if (!err) {
          var tipText = (self.proxyType === T_TYPE_HTTP ? 'Http' : 'Https') + ' proxy started on port ' + self.proxyPort;
          logUtil.printLog(color.green(tipText));

          if (self.webServerInstance) {
            var webTip = 'web interface started on port ' + self.webServerInstance.webPort;
            logUtil.printLog(color.green(webTip));
          }

          var ruleSummaryString = '';
          var proxyRule = _this2.proxyRule;


          var func = function func(ruleSummary) {
            if (ruleSummary) {
              co( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!(typeof ruleSummary === 'string')) {
                          _context.next = 4;
                          break;
                        }

                        ruleSummaryString = ruleSummary;
                        _context.next = 7;
                        break;

                      case 4:
                        _context.next = 6;
                        return ruleSummary();

                      case 6:
                        ruleSummaryString = _context.sent;

                      case 7:

                        logUtil.printLog(color.green('Active rule is: ' + ruleSummaryString));

                      case 8:
                      case 'end':
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));
            }
          };

          if (proxyRule instanceof Array) {
            proxyRule.forEach(function (item) {
              var summary = item.summary;

              func(summary);
            });
          } else {
            var summary = proxyRule.summary;

            func(summary);
          }

          self.status = PROXY_STATUS_READY;
          self.emit('ready');
        } else {
          var _tipText = 'err when start proxy server :(';
          logUtil.printLog(color.red(_tipText), logUtil.T_ERR);
          logUtil.printLog(err, logUtil.T_ERR);
          self.emit('error', {
            error: err
          });
        }
      });

      return self;
    }

    /**
     * close the proxy server
     *
     * @returns ProxyCore
     *
     * @memberOf ProxyCore
     */

  }, {
    key: 'close',
    value: function close() {
      var _this3 = this;

      // clear recorder cache
      return new Promise(function (resolve) {
        if (_this3.httpProxyServer) {
          // destroy conns & cltSockets when close proxy server
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _this3.requestHandler.conns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
                  _key = _step$value[0],
                  conn = _step$value[1];

              logUtil.printLog('destorying https connection : ' + _key);
              conn.end();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = _this3.requestHandler.cltSockets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _step2$value = (0, _slicedToArray3.default)(_step2.value, 2),
                  _key2 = _step2$value[0],
                  cltSocket = _step2$value[1];

              logUtil.printLog('endding https cltSocket : ' + _key2);
              cltSocket.end();
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          if (_this3.socketPool) {
            for (var key in _this3.socketPool) {
              _this3.socketPool[key].destroy();
            }
          }

          _this3.httpProxyServer.close(function (error) {
            if (error) {
              console.error(error);
              logUtil.printLog('proxy server close FAILED : ' + error.message, logUtil.T_ERR);
            } else {
              _this3.httpProxyServer = null;

              _this3.status = PROXY_STATUS_CLOSED;
              logUtil.printLog('proxy server closed at ' + _this3.proxyHostName + ':' + _this3.proxyPort);
            }
            resolve(error);
          });
        } else {
          resolve();
        }
      });
    }
  }]);
  return ProxyCore;
}(events.EventEmitter);

/**
 * start proxy server as well as recorder and webInterface
 */


var ProxyServer = function (_ProxyCore) {
  (0, _inherits3.default)(ProxyServer, _ProxyCore);

  /**
   *
   * @param {object} config - config
   * @param {object} [config.webInterface] - config of the web interface
   * @param {boolean} [config.webInterface.enable=false] - if web interface is enabled
   * @param {number} [config.webInterface.webPort=8002] - http port of the web interface
   * @param {number} [config.webInterface.wsPort] - web socket port of the web interface
   */
  function ProxyServer(config) {
    (0, _classCallCheck3.default)(this, ProxyServer);

    // prepare a recorder
    var recorder = new Recorder();
    var configForCore = Object.assign({
      recorder: recorder
    }, config);

    var _this4 = (0, _possibleConstructorReturn3.default)(this, (ProxyServer.__proto__ || Object.getPrototypeOf(ProxyServer)).call(this, configForCore));

    _this4.proxyWebinterfaceConfig = config.webInterface;
    _this4.recorder = recorder;
    _this4.webServerInstance = null;
    return _this4;
  }

  (0, _createClass3.default)(ProxyServer, [{
    key: 'start',
    value: function start() {
      var _this5 = this;

      // start web interface if neeeded
      if (this.proxyWebinterfaceConfig && this.proxyWebinterfaceConfig.enable) {
        this.webServerInstance = new WebInterface(this.proxyWebinterfaceConfig, this.recorder);
      }

      // start web server
      this.webServerInstance.start().then(function () {
        // start proxy core
        (0, _get3.default)(ProxyServer.prototype.__proto__ || Object.getPrototypeOf(ProxyServer.prototype), 'start', _this5).call(_this5);
      }).catch(function (e) {
        _this5.emit('error', e);
      });
    }
  }, {
    key: 'close',
    value: function close() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        (0, _get3.default)(ProxyServer.prototype.__proto__ || Object.getPrototypeOf(ProxyServer.prototype), 'close', _this6).call(_this6).then(function (error) {
          if (error) {
            resolve(error);
            return;
          }
        });

        if (_this6.recorder) {
          logUtil.printLog('clearing cache file...');
          _this6.recorder.clear();
        }
        var tmpWebServer = _this6.webServerInstance;
        _this6.recorder = null;
        _this6.webServerInstance = null;
        if (tmpWebServer) {
          logUtil.printLog('closing webserver...');
          tmpWebServer.close(function (error) {
            if (error) {
              console.error(error);
              logUtil.printLog('proxy web server close FAILED: ' + error.message, logUtil.T_ERR);
            } else {
              logUtil.printLog('proxy web server closed at ' + _this6.proxyHostName + ' : ' + _this6.webPort);
            }

            resolve(error);
          });
        } else {
          resolve(null);
        }
      });
    }
  }]);
  return ProxyServer;
}(ProxyCore);

module.exports.ProxyCore = ProxyCore;
module.exports.ProxyServer = ProxyServer;
module.exports.ProxyRecorder = Recorder;
module.exports.ProxyWebServer = WebInterface;
module.exports.utils = {
  systemProxyMgr: require('./lib/systemProxyMgr'),
  certMgr: certMgr
};