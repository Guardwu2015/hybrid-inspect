'use strict';
//websocket server manager

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WebSocketServer = require('ws').Server;
var logUtil = require('./log');

function resToMsg(msg, recorder, cb) {
  var result = {},
      jsonData = void 0;

  try {
    jsonData = JSON.parse(msg);
  } catch (e) {
    result = {
      type: 'error',
      error: 'failed to parse your request : ' + e.toString()
    };
    cb && cb(result);
    return;
  }

  if (jsonData.reqRef) {
    result.reqRef = jsonData.reqRef;
  }

  if (jsonData.type === 'reqBody' && jsonData.id) {
    result.type = 'body';
    recorder.getBody(jsonData.id, function (err, data) {
      if (err) {
        result.content = {
          id: null,
          body: null,
          error: err.toString()
        };
      } else {
        result.content = {
          id: jsonData.id,
          body: data.toString()
        };
      }
      cb && cb(result);
    });
  } else {
    // more req handler here
    return null;
  }
}

//config.port

var wsServer = function () {
  function wsServer(config, recorder) {
    (0, _classCallCheck3.default)(this, wsServer);

    if (!recorder) {
      throw new Error('proxy recorder is required');
    } else if (!config || !config.port) {
      throw new Error('config.port is required');
    }

    var self = this;
    self.config = config;
    self.recorder = recorder;
  }

  (0, _createClass3.default)(wsServer, [{
    key: 'start',
    value: function start() {
      var self = this;
      var config = self.config;
      var recorder = self.recorder;
      return new Promise(function (resolve, reject) {
        //web socket interface
        var wss = new WebSocketServer({
          port: config.port,
          clientTracking: true
        }, resolve);

        logUtil.printLog('WebSoket setup at port ' + config.port + ' ', logUtil.T_DEBUG);
        // the queue of the messages to be delivered
        var messageQueue = [];
        // the flat to indicate wheter to broadcast the record
        var broadcastFlag = true;

        setInterval(function () {
          broadcastFlag = true;
          sendMultipleMessage();
        }, 50);

        function sendMultipleMessage(data) {
          // if the flag goes to be true, and there are records to send
          if (broadcastFlag && messageQueue.length > 0) {
            wss && wss.broadcast({
              type: 'updateMultiple',
              content: messageQueue
            });
            messageQueue = [];
            broadcastFlag = false;
          } else {
            data && messageQueue.push(data);
          }
        }

        wss.broadcast = function (data) {
          if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) === 'object') {
            data = JSON.stringify(data);
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = wss.clients[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var client = _step.value;

              try {
                client.send(data);
              } catch (e) {
                logUtil.printLog('websocket failed to send data, ' + e, logUtil.T_ERR);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        };

        wss.on('connection', function (ws) {
          ws.on('message', function (msg) {
            resToMsg(msg, recorder, function (res) {
              res && ws.send(JSON.stringify(res));
            });
          });

          ws.on('error', function (e) {
            console.error('error in ws:', e);
          });
        });

        wss.on('error', function (e) {
          logUtil.printLog('websocket error, ' + e, logUtil.T_ERR);
        });

        wss.on('close', function () {});

        recorder.on('update', function (data) {
          try {
            sendMultipleMessage(data);
          } catch (e) {
            console.log('ws error');
            console.log(e);
          }
        });

        self.wss = wss;
      });
    }
  }, {
    key: 'closeAll',
    value: function closeAll() {
      var self = this;
      return new Promise(function (resolve, reject) {
        self.wss.close(function (e) {
          if (e) {
            reject(e);
          } else {
            resolve();
          }
        });
      });
    }
  }]);
  return wsServer;
}();

module.exports = wsServer;