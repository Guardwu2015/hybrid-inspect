'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var http = require('http'),
    https = require('https'),
    net = require('net'),
    url = require('url'),
    zlib = require('zlib'),
    color = require('colorful'),
    Buffer = require('buffer').Buffer,
    util = require('./util'),
    Stream = require('stream'),
    logUtil = require('./log'),
    co = require('co'),
    pug = require('pug'),
    HttpsServerMgr = require('./httpsServerMgr'),
    Readable = require('stream').Readable,
    _ = require('lodash');
// gUtil = require('util');


// to fix issue with TLS cache, refer to: https://github.com/nodejs/node/issues/8368
https.globalAgent.maxCachedSessions = 0;

var error502PugFn = pug.compileFile(require('path').join(__dirname, '../resource/502.pug'));
var DEFAULT_CHUNK_COLLECT_THRESHOLD = 20 * 1024 * 1024; // about 20 mb

var CommonReadableStream = function (_Readable) {
  (0, _inherits3.default)(CommonReadableStream, _Readable);

  function CommonReadableStream(config) {
    (0, _classCallCheck3.default)(this, CommonReadableStream);
    return (0, _possibleConstructorReturn3.default)(this, (CommonReadableStream.__proto__ || Object.getPrototypeOf(CommonReadableStream)).call(this, {
      highWaterMark: DEFAULT_CHUNK_COLLECT_THRESHOLD * 5
    }));
  }

  (0, _createClass3.default)(CommonReadableStream, [{
    key: '_read',
    value: function _read(size) {}
  }]);
  return CommonReadableStream;
}(Readable);

/**
 * fetch remote response
 *
 * @param {string} protocol
 * @param {object} options options of http.request
 * @param {buffer} reqData request body
 * @param {object} config
 * @param {boolean} config.dangerouslyIgnoreUnauthorized
 * @param {boolean} config.chunkSizeThreshold
 * @returns
 */


function fetchRemoteResponse(protocol, options, reqData, config) {
  reqData = reqData || '';
  return new Promise(function (resolve, reject) {
    delete options.headers['content-length']; // will reset the content-length after rule
    delete options.headers['Content-Length'];
    delete options.headers['Transfer-Encoding'];
    delete options.headers['transfer-encoding'];

    if (config.dangerouslyIgnoreUnauthorized) {
      options.rejectUnauthorized = false;
    }

    if (!config.chunkSizeThreshold) {
      throw new Error('chunkSizeThreshold is required');
    }
    //send request
    // console.log(gUtil.inspect(options));
    var proxyReq = (/https/i.test(protocol) ? https : http).request(options, function (res) {
      res.headers = util.getHeaderFromRawHeaders(res.rawHeaders);
      //deal response header
      var statusCode = res.statusCode;
      var resHeader = res.headers;
      var resDataChunks = []; // array of data chunks or stream
      var rawResChunks = []; // the original response chunks
      var resDataStream = null;
      var resSize = 0;
      var finishCollecting = function finishCollecting() {
        new Promise(function (fulfill, rejectParsing) {
          if (resDataStream) {
            fulfill(resDataStream);
          } else {
            var serverResData = Buffer.concat(resDataChunks);

            // put origin content length into header
            resHeader['x-anyproxy-origin-content-length'] = util.getByteSize(serverResData);

            if (ifServerGzipped) {
              zlib.gunzip(serverResData, function (err, buff) {
                // TODO test case to cover
                if (err) {
                  rejectParsing(err);
                } else {
                  fulfill(buff);
                }
              });
            } else if (isServerDeflated) {
              zlib.inflateRaw(serverResData, function (err, buff) {
                // TODO test case to cover
                if (err) {
                  rejectParsing(err);
                } else {
                  fulfill(buff);
                }
              });
            } else {
              fulfill(serverResData);
            }
          }
        }).then(function (serverResData) {
          resolve({
            statusCode: statusCode,
            header: resHeader,
            body: serverResData,
            rawBody: rawResChunks,
            _res: res
          });
        }).catch(function (e) {
          reject(e);
        });
      };

      // remove gzip related header, and ungzip the content
      // note there are other compression types like deflate
      var contentEncoding = resHeader['content-encoding'] || resHeader['Content-Encoding'];
      var ifServerGzipped = /gzip/i.test(contentEncoding);
      var isServerDeflated = /deflate/i.test(contentEncoding);

      //deal response data
      res.on('data', function (chunk) {
        rawResChunks.push(chunk);
        if (resDataStream) {
          // stream mode
          resDataStream.push(chunk);
          return;
        } else {
          // dataChunks
          resSize += chunk.length;
          resDataChunks.push(chunk);

          // stop collecting, convert to stream mode
          if (resSize >= config.chunkSizeThreshold) {
            resDataStream = new CommonReadableStream();
            while (resDataChunks.length) {
              resDataStream.push(resDataChunks.shift());
            }
            resDataChunks = null;
            finishCollecting();
          }
        }
      });

      res.on('end', function () {
        if (resDataStream) {
          resDataStream.emit('end'); // EOF
        } else {
          finishCollecting();
        }
      });
      res.on('error', function (error) {
        logUtil.printLog('error happend in response:' + error, logUtil.T_ERR);
        reject(error);
      });
    });

    proxyReq.on('error', reject);
    proxyReq.end(reqData);
  });
}

/**
 * get a request handler for http/https server
 *
 * @param {RequestHandler} reqHandlerCtx
 * @param { Array} userRule
 * @param {Recorder} recorder
 * @returns
 */
function getUserReqHandler(userRule, recorder) {
  var reqHandlerCtx = this;

  return function (req, userRes) {
    /*
    note
      req.url is wired
      in http  server: http://www.example.com/a/b/c
      in https server: /a/b/c
    */

    var host = req.headers.host;
    var protocol = !!req.connection.encrypted && !/^http:/.test(req.url) ? 'https' : 'http';
    var fullUrl = protocol === 'http' ? req.url : protocol + '://' + host + req.url;

    var urlPattern = url.parse(fullUrl);
    var path = urlPattern.path;
    var chunkSizeThreshold = DEFAULT_CHUNK_COLLECT_THRESHOLD;

    var resourceInfo = null;
    var resourceInfoId = -1;
    var reqData = void 0;
    var requestDetail = void 0;

    // refer to https://github.com/alibaba/anyproxy/issues/103
    // construct the original headers as the reqheaders
    req.headers = util.getHeaderFromRawHeaders(req.rawHeaders);

    logUtil.printLog(color.green('received request to: ' + req.method + ' ' + host + path));

    /**
     * fetch complete req data
     */
    var fetchReqData = function fetchReqData() {
      return new Promise(function (resolve) {
        var postData = [];
        req.on('data', function (chunk) {
          postData.push(chunk);
        });
        req.on('end', function () {
          reqData = Buffer.concat(postData);
          // console.log(gUtil.inspect(reqData.toString()));
          resolve();
        });
      });
    };

    /**
     * prepare detailed request info
     */
    var prepareRequestDetail = function prepareRequestDetail() {
      var options = {
        hostname: urlPattern.hostname || req.headers.host,
        port: urlPattern.port || req.port || (/https/.test(protocol) ? 443 : 80),
        path: path,
        method: req.method,
        headers: req.headers
      };

      requestDetail = {
        requestOptions: options,
        protocol: protocol,
        url: fullUrl,
        requestData: reqData,
        _req: req
      };

      return Promise.resolve();
    };

    /**
    * send response to client
    *
    * @param {object} finalResponseData
    * @param {number} finalResponseData.statusCode
    * @param {object} finalResponseData.header
    * @param {buffer|string} finalResponseData.body
    */
    var sendFinalResponse = function sendFinalResponse(finalResponseData) {
      var responseInfo = finalResponseData.response;
      var resHeader = responseInfo.header;
      var responseBody = responseInfo.body || '';

      var transferEncoding = resHeader['transfer-encoding'] || resHeader['Transfer-Encoding'] || '';
      var contentEncoding = resHeader['content-encoding'] || resHeader['Content-Encoding'];
      var contentLength = resHeader['content-length'] || resHeader['Content-Length'];
      if (contentLength) {
        delete resHeader['content-length'];
        delete resHeader['Content-Length'];
      }

      if (contentEncoding) {
        resHeader['x-anyproxy-origin-content-encoding'] = contentEncoding;
        delete resHeader['content-encoding'];
        delete resHeader['Content-Encoding'];
      }

      if (!responseInfo) {
        throw new Error('failed to get response info');
      } else if (!responseInfo.statusCode) {
        throw new Error('failed to get response status code');
      } else if (!responseInfo.header) {
        throw new Error('filed to get response header');
      }
      // if there is no transfer-encoding, set the content-length
      if (!global._throttle && transferEncoding !== 'chunked' && !(responseBody instanceof CommonReadableStream)) {
        resHeader['Content-Length'] = util.getByteSize(responseBody);
      }

      userRes.writeHead(responseInfo.statusCode, resHeader);

      if (global._throttle) {
        if (responseBody instanceof CommonReadableStream) {
          responseBody.pipe(global._throttle.throttle()).pipe(userRes);
        } else {
          var thrStream = new Stream();
          thrStream.pipe(global._throttle.throttle()).pipe(userRes);
          thrStream.emit('data', responseBody);
          thrStream.emit('end');
        }
      } else {
        if (responseBody instanceof CommonReadableStream) {
          responseBody.pipe(userRes);
        } else {
          userRes.end(responseBody);
        }
      }

      return responseInfo;
    };

    // fetch complete request data
    co(fetchReqData).then(prepareRequestDetail).then(function () {
      // record request info
      if (recorder) {
        resourceInfo = {
          host: host,
          method: req.method,
          path: path,
          protocol: protocol,
          url: protocol + '://' + host + path,
          req: req,
          startTime: new Date().getTime()
        };
        resourceInfoId = recorder.appendRecord(resourceInfo);
      }

      try {
        resourceInfo.reqBody = reqData.toString(); //TODO: deal reqBody in webInterface.js
        recorder && recorder.updateRecord(resourceInfoId, resourceInfo);
      } catch (e) {}
    })

    // invoke rule before sending request
    .then(co.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var userModifiedInfo, userRuleArray, iIndex, item, temp, finalReqDetail;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              userModifiedInfo = _.cloneDeep(requestDetail);
              userRuleArray = userRule;
              iIndex = 0;

            case 3:
              if (!(iIndex < userRuleArray.length)) {
                _context.next = 15;
                break;
              }

              item = userRuleArray[iIndex];
              _context.next = 7;
              return item.beforeSendRequest(_.assign({}, userModifiedInfo));

            case 7:
              _context.t0 = _context.sent;

              if (_context.t0) {
                _context.next = 10;
                break;
              }

              _context.t0 = {};

            case 10:
              temp = _context.t0;

              userModifiedInfo = _.assign({}, userModifiedInfo, temp);

            case 12:
              iIndex++;
              _context.next = 3;
              break;

            case 15:
              finalReqDetail = {};

              ['protocol', 'requestOptions', 'requestData', 'response'].map(function (key) {
                finalReqDetail[key] = userModifiedInfo[key] || requestDetail[key];
              });
              return _context.abrupt('return', finalReqDetail);

            case 18:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    })))

    // route user config
    .then(co.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee2(userConfig) {
      var remoteResponse;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!userConfig.response) {
                _context2.next = 5;
                break;
              }

              // user-assigned local response
              userConfig._directlyPassToRespond = true;
              return _context2.abrupt('return', userConfig);

            case 5:
              if (!userConfig.requestOptions) {
                _context2.next = 12;
                break;
              }

              _context2.next = 8;
              return fetchRemoteResponse(userConfig.protocol, userConfig.requestOptions, userConfig.requestData, {
                dangerouslyIgnoreUnauthorized: reqHandlerCtx.dangerouslyIgnoreUnauthorized,
                chunkSizeThreshold: chunkSizeThreshold
              });

            case 8:
              remoteResponse = _context2.sent;
              return _context2.abrupt('return', {
                response: {
                  statusCode: remoteResponse.statusCode,
                  header: remoteResponse.header,
                  body: remoteResponse.body,
                  rawBody: remoteResponse.rawBody
                },
                _res: remoteResponse._res
              });

            case 12:
              throw new Error('lost response or requestOptions, failed to continue');

            case 13:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    })))

    // invoke rule before responding to client
    .then(co.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee3(responseData) {
      var userModifiedResponseData, userRuleArray, iIndex, userRuleItem, temp;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!responseData._directlyPassToRespond) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt('return', responseData);

            case 4:
              if (!(responseData.response.body && responseData.response.body instanceof CommonReadableStream)) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt('return', responseData);

            case 8:
              // TODO: err etimeout
              userModifiedResponseData = responseData;
              userRuleArray = userRule;
              iIndex = 0;

            case 11:
              if (!(iIndex < userRuleArray.length)) {
                _context3.next = 20;
                break;
              }

              userRuleItem = userRuleArray[iIndex];
              _context3.next = 15;
              return userRuleItem.beforeSendResponse(Object.assign({}, requestDetail), Object.assign({}, userModifiedResponseData));

            case 15:
              temp = _context3.sent;

              // 防止没有实现该rule的接口返回为null影响结果
              if (temp) {
                userModifiedResponseData = temp;
              }

            case 17:
              iIndex++;
              _context3.next = 11;
              break;

            case 20:
              return _context3.abrupt('return', userModifiedResponseData || responseData);

            case 21:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }))).catch(co.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee4(error) {
      var content, errorResponse, userRuleArray, userResponse, iIndex, item, tempUserResponse;
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              logUtil.printLog(util.collectErrorLog(error), logUtil.T_ERR);

              content = void 0;

              try {
                content = error502PugFn({
                  error: error,
                  url: fullUrl,
                  errorStack: error.stack.split(/\n/)
                });
              } catch (parseErro) {
                content = error.stack;
              }

              // default error response
              errorResponse = {
                statusCode: 500,
                header: {
                  'Content-Type': 'text/html; charset=utf-8',
                  'Proxy-Error': true,
                  'Proxy-Error-Message': error || 'null'
                },
                body: content
              };

              // call user rule

              _context4.prev = 4;
              userRuleArray = userRule;
              userResponse = {};
              iIndex = 0;

            case 8:
              if (!(iIndex < userRuleArray.length)) {
                _context4.next = 17;
                break;
              }

              item = userRuleArray[iIndex];
              _context4.next = 12;
              return item.onError(Object.assign({}, requestDetail), error);

            case 12:
              tempUserResponse = _context4.sent;

              userResponse = _.assign({}, userResponse, tempUserResponse);

            case 14:
              iIndex++;
              _context4.next = 8;
              break;

            case 17:
              // const userResponse = yield userRule.onError(Object.assign({}, requestDetail), error);
              if (userResponse && userResponse.response && userResponse.response.header) {
                errorResponse = userResponse.response;
              }
              _context4.next = 22;
              break;

            case 20:
              _context4.prev = 20;
              _context4.t0 = _context4['catch'](4);

            case 22:
              return _context4.abrupt('return', {
                response: errorResponse
              });

            case 23:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, this, [[4, 20]]);
    }))).then(sendFinalResponse)

    //update record info
    .then(function (responseInfo) {
      resourceInfo.endTime = new Date().getTime();
      resourceInfo.res = { //construct a self-defined res object
        statusCode: responseInfo.statusCode,
        headers: responseInfo.header
      };

      resourceInfo.statusCode = responseInfo.statusCode;
      resourceInfo.resHeader = responseInfo.header;
      resourceInfo.resBody = responseInfo.body instanceof CommonReadableStream ? '(big stream)' : responseInfo.body || '';
      resourceInfo.length = resourceInfo.resBody.length;

      // console.info('===> resbody in record', resourceInfo);

      recorder && recorder.updateRecord(resourceInfoId, resourceInfo);
    }).catch(function (e) {
      logUtil.printLog(color.green('Send final response failed:' + e.message), logUtil.T_ERR);
    });
  };
}

/**
 * get a handler for CONNECT request
 *
 * @param {RequestHandler} reqHandlerCtx
 * @param {Array} userRule
 * @param {Recorder} recorder
 * @param {object} httpsServerMgr
 * @returns
 */
function getConnectReqHandler(userRule, recorder, httpsServerMgr) {
  var reqHandlerCtx = this;reqHandlerCtx.conns = new Map();reqHandlerCtx.cltSockets = new Map();

  return function (req, cltSocket, head) {
    var host = req.url.split(':')[0],
        targetPort = req.url.split(':')[1];

    var shouldIntercept = void 0;
    var requestDetail = void 0;
    var requestStream = new CommonReadableStream();

    /*
      1. write HTTP/1.1 200 to client
      2. get request data
      3. tell if it is a websocket request
      4.1 if (websocket || do_not_intercept) --> pipe to target server
      4.2 else --> pipe to local server and do man-in-the-middle attack
    */
    co( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
      var userRuleArray, iIndex, item;
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // determine whether to use the man-in-the-middle server
              logUtil.printLog(color.green('received https CONNECT request ' + host));

              if (!reqHandlerCtx.forceProxyHttps) {
                _context5.next = 5;
                break;
              }

              shouldIntercept = true;
              _context5.next = 20;
              break;

            case 5:
              requestDetail = {
                host: req.url,
                _req: req
              };
              userRuleArray = userRule;

              shouldIntercept = false;
              iIndex = 0;

            case 9:
              if (!(iIndex < userRuleArray.length)) {
                _context5.next = 20;
                break;
              }

              item = userRuleArray[iIndex];
              _context5.t0 = shouldIntercept;

              if (_context5.t0) {
                _context5.next = 16;
                break;
              }

              _context5.next = 15;
              return item.beforeDealHttpsRequest(requestDetail);

            case 15:
              _context5.t0 = _context5.sent;

            case 16:
              shouldIntercept = _context5.t0;

            case 17:
              iIndex++;
              _context5.next = 9;
              break;

            case 20:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, this);
    })

    // shouldIntercept = yield userRule.beforeDealHttpsRequest(requestDetail);
    ).then(new Promise(function (resolve) {
      // mark socket connection as established, to detect the request protocol
      cltSocket.write('HTTP/' + req.httpVersion + ' 200 OK\r\n\r\n', 'UTF-8', resolve);
    })).then(new Promise(function (resolve, reject) {
      var resolved = false;
      cltSocket.on('data', function (chunk) {
        requestStream.push(chunk);
        if (!resolved) {
          resolved = true;
          try {
            var chunkString = chunk.toString();
            if (chunkString.indexOf('GET ') === 0) {
              shouldIntercept = false; //websocket
            }
          } catch (e) {}
          resolve();
        }
      });
      cltSocket.on('end', function () {
        requestStream.push(null);
      });
    })).then(function () {
      // log and recorder
      if (shouldIntercept) {
        logUtil.printLog('will forward to local https server');
      } else {
        logUtil.printLog('will bypass the man-in-the-middle proxy');
      }

      //record
      // resourceInfo = {
      //   host,
      //   method: req.method,
      //   path: '',
      //   url: 'https://' + host,
      //   req,
      //   startTime: new Date().getTime()
      // };
      // resourceInfoId = recorder.appendRecord(resourceInfo);
    }).then(function () {
      // determine the request target
      if (!shouldIntercept) {
        return {
          host: host,
          port: targetPort === 80 ? 443 : targetPort
        };
      } else {
        return httpsServerMgr.getSharedHttpsServer().then(function (serverInfo) {
          return { host: serverInfo.host, port: serverInfo.port };
        });
      }
    }).then(function (serverInfo) {
      if (!serverInfo.port || !serverInfo.host) {
        throw new Error('failed to get https server info');
      }

      return new Promise(function (resolve, reject) {
        var conn = net.connect(serverInfo.port, serverInfo.host, function () {
          //throttle for direct-foward https
          if (global._throttle && !shouldIntercept) {
            requestStream.pipe(conn);
            conn.pipe(global._throttle.throttle()).pipe(cltSocket);
          } else {
            requestStream.pipe(conn);
            conn.pipe(cltSocket);
          }

          resolve();
        });

        conn.on('error', function (e) {
          reject(e);
        });

        reqHandlerCtx.conns.set(serverInfo.host + ':' + serverInfo.port, conn);
        reqHandlerCtx.cltSockets.set(serverInfo.host + ':' + serverInfo.port, cltSocket);
      });
    }).then(function () {
      // resourceInfo.endTime = new Date().getTime();
      // resourceInfo.statusCode = '200';
      // resourceInfo.resHeader = {};
      // resourceInfo.resBody = '';
      // resourceInfo.length = 0;

      // recorder && recorder.updateRecord(resourceInfoId, resourceInfo);
    }).catch(co.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee6(error) {
      var userRuleArray, iIndex, item, errorHeader;
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              logUtil.printLog(util.collectErrorLog(error), logUtil.T_ERR);

              _context6.prev = 1;
              userRuleArray = userRule;
              iIndex = 0;

            case 4:
              if (!(iIndex < userRuleArray.length)) {
                _context6.next = 11;
                break;
              }

              item = userRuleArray[iIndex];
              _context6.next = 8;
              return item.onConnectError(requestDetail, error);

            case 8:
              iIndex++;
              _context6.next = 4;
              break;

            case 11:
              _context6.next = 15;
              break;

            case 13:
              _context6.prev = 13;
              _context6.t0 = _context6['catch'](1);

            case 15:

              try {
                errorHeader = 'Proxy-Error: true\r\n';

                errorHeader += 'Proxy-Error-Message: ' + (error || 'null') + '\r\n';
                errorHeader += 'Content-Type: text/html\r\n';
                cltSocket.write('HTTP/1.1 502\r\n' + errorHeader + '\r\n\r\n');
              } catch (e) {}

            case 16:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, this, [[1, 13]]);
    })));
  };
}

var RequestHandler =

/**
 * Creates an instance of RequestHandler.
 *
 * @param {object} config
 * @param {boolean} config.forceProxyHttps proxy all https requests
 * @param {boolean} config.dangerouslyIgnoreUnauthorized
 * @param {object | Array} rule
 * @param {Recorder} recorder
 *
 * @memberOf RequestHandler
 */
function RequestHandler(config, rule, recorder) {
  (0, _classCallCheck3.default)(this, RequestHandler);

  var reqHandlerCtx = this;
  if (config.forceProxyHttps) {
    this.forceProxyHttps = true;
  }
  if (config.dangerouslyIgnoreUnauthorized) {
    this.dangerouslyIgnoreUnauthorized = true;
  }
  var default_rule = util.freshRequire('./rule_default');

  // const userRule = util.merge(default_rule, rule);
  var ruleArray = rule;
  var userRule = ruleArray.map(function (item) {
    return _.assign({}, default_rule, item);
  });
  reqHandlerCtx.userRequestHandler = getUserReqHandler.apply(reqHandlerCtx, [userRule, recorder]);

  reqHandlerCtx.httpsServerMgr = new HttpsServerMgr({
    handler: reqHandlerCtx.userRequestHandler
  });

  this.connectReqHandler = getConnectReqHandler.apply(reqHandlerCtx, [userRule, recorder, reqHandlerCtx.httpsServerMgr]);
};

module.exports = RequestHandler;